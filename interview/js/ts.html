<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Yolo</title>
    <meta name="generator" content="VuePress 1.9.9">
    
    <meta name="description" content="">
    <meta name="referrer" content="no-referrer">
    
    <link rel="preload" href="/blog/assets/css/0.styles.671fbdd0.css" as="style"><link rel="preload" href="/blog/assets/js/app.1b73a34e.js" as="script"><link rel="preload" href="/blog/assets/js/2.733019b2.js" as="script"><link rel="preload" href="/blog/assets/js/27.704b5b19.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.302da1cf.js"><link rel="prefetch" href="/blog/assets/js/11.49cb5a17.js"><link rel="prefetch" href="/blog/assets/js/12.cc05ffa9.js"><link rel="prefetch" href="/blog/assets/js/13.bc6a6d00.js"><link rel="prefetch" href="/blog/assets/js/14.49df6a75.js"><link rel="prefetch" href="/blog/assets/js/15.672d9069.js"><link rel="prefetch" href="/blog/assets/js/16.8a0222c4.js"><link rel="prefetch" href="/blog/assets/js/17.d45e1d15.js"><link rel="prefetch" href="/blog/assets/js/18.670357ed.js"><link rel="prefetch" href="/blog/assets/js/19.8df598c5.js"><link rel="prefetch" href="/blog/assets/js/20.4493dfa7.js"><link rel="prefetch" href="/blog/assets/js/21.29efc0e0.js"><link rel="prefetch" href="/blog/assets/js/22.dee43871.js"><link rel="prefetch" href="/blog/assets/js/23.12c95ddc.js"><link rel="prefetch" href="/blog/assets/js/24.fc85ab8b.js"><link rel="prefetch" href="/blog/assets/js/25.d2553c7d.js"><link rel="prefetch" href="/blog/assets/js/26.13251b4e.js"><link rel="prefetch" href="/blog/assets/js/28.073d1c04.js"><link rel="prefetch" href="/blog/assets/js/29.82ede666.js"><link rel="prefetch" href="/blog/assets/js/3.420c64ab.js"><link rel="prefetch" href="/blog/assets/js/30.4e4e5bbf.js"><link rel="prefetch" href="/blog/assets/js/31.7ac6d421.js"><link rel="prefetch" href="/blog/assets/js/32.1a06c393.js"><link rel="prefetch" href="/blog/assets/js/33.7eb5807c.js"><link rel="prefetch" href="/blog/assets/js/34.44b85fd5.js"><link rel="prefetch" href="/blog/assets/js/35.3bcdab5e.js"><link rel="prefetch" href="/blog/assets/js/36.4b30ada3.js"><link rel="prefetch" href="/blog/assets/js/37.372eef9f.js"><link rel="prefetch" href="/blog/assets/js/38.eb5538b0.js"><link rel="prefetch" href="/blog/assets/js/39.615f174c.js"><link rel="prefetch" href="/blog/assets/js/4.d12742be.js"><link rel="prefetch" href="/blog/assets/js/40.b9313f5d.js"><link rel="prefetch" href="/blog/assets/js/41.9120b576.js"><link rel="prefetch" href="/blog/assets/js/42.f5a93f99.js"><link rel="prefetch" href="/blog/assets/js/43.12e57085.js"><link rel="prefetch" href="/blog/assets/js/44.5f50fa3f.js"><link rel="prefetch" href="/blog/assets/js/45.167bfe07.js"><link rel="prefetch" href="/blog/assets/js/46.2c467463.js"><link rel="prefetch" href="/blog/assets/js/47.d6509dea.js"><link rel="prefetch" href="/blog/assets/js/5.216cae74.js"><link rel="prefetch" href="/blog/assets/js/6.2d0a63f8.js"><link rel="prefetch" href="/blog/assets/js/7.9c9172a7.js"><link rel="prefetch" href="/blog/assets/js/8.c310a593.js"><link rel="prefetch" href="/blog/assets/js/9.d9b0c4aa.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.671fbdd0.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">Yolo</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/internet/计算机网络简史.html" class="nav-link">
  计网
</a></div><div class="nav-item"><a href="/blog/frame/" class="nav-link">
  框架
</a></div><div class="nav-item"><a href="/blog/utils/源码阅读.html" class="nav-link">
  工具
</a></div><div class="nav-item"><a href="/blog/interview/vue/" class="nav-link">
  面试
</a></div> <a href="https://github.com/SetoInlandSea/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/internet/计算机网络简史.html" class="nav-link">
  计网
</a></div><div class="nav-item"><a href="/blog/frame/" class="nav-link">
  框架
</a></div><div class="nav-item"><a href="/blog/utils/源码阅读.html" class="nav-link">
  工具
</a></div><div class="nav-item"><a href="/blog/interview/vue/" class="nav-link">
  面试
</a></div> <a href="https://github.com/SetoInlandSea/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>计网</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/internet/计算机网络简史.html" class="sidebar-link">计算机网络简史</a></li><li><a href="/blog/internet/OSI七层模型.html" class="sidebar-link">OSI七层模型</a></li><li><a href="/blog/internet/TCP_IP协议群.html" class="sidebar-link">TCP_IP协议群</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>框架</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/frame/" class="sidebar-link">首页</a></li><li><a href="/blog/frame/vue/vue3.0项目工程环境.html" class="sidebar-link">vue3.0项目工程环境</a></li><li><a href="/blog/frame/vue/vue3.html" class="sidebar-link">vue3</a></li><li><a href="/blog/frame/vue/大文件上传.html" class="sidebar-link">大文件上传</a></li><li><a href="/blog/frame/react/" class="sidebar-link">react</a></li><li><a href="/blog/frame/other/nuxt.html" class="sidebar-link">nuxt</a></li><li><a href="/blog/frame/other/electron.html" class="sidebar-link">electron</a></li><li><a href="/blog/frame/常用的方法.html" class="sidebar-link">常用的方法</a></li><li><a href="/blog/frame/字符串技巧.html" class="sidebar-link">字符串技巧</a></li><li><a href="/blog/frame/黑魔法.html" class="sidebar-link">黑魔法</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>工具</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/utils/源码阅读.html" class="sidebar-link">源码阅读</a></li><li><a href="/blog/utils/Chrome debugger.html" class="sidebar-link">Chrome debugger</a></li><li><a href="/blog/utils/git.html" class="sidebar-link">git</a></li><li><a href="/blog/utils/Chrome扩展插件.html" class="sidebar-link">Chrome扩展插件</a></li><li><a href="/blog/utils/npm发布.html" class="sidebar-link">npm发布</a></li><li><a href="/blog/utils/shell.html" class="sidebar-link">shell</a></li><li><a href="/blog/utils/前端工具.html" class="sidebar-link">前端工具</a></li><li><a href="/blog/utils/webpack.html" class="sidebar-link">webpack</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>产品</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>面试</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>分享</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p><a href="https://ts.xcatliu.com/introduction/index.html" target="_blank" rel="noopener noreferrer">TS入门<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>
专业流程平台Vue+TypeScript实践分享
项⽬是基于BPMN的规范来做的⼀个流程设计器，前端的技术框架基于Vue，使⽤ TypeScript 来编写
 
什么是TypeScript？
• TypeScript是⼀种由微软开发的开源、跨平台的编程语⾔。它是JavaScript的超集，最终会被编译 为JavaScript代码。
• TypeScript添加了可选的静态类型系统和很多尚未正式发布的ECMAScript新特性。
• TypeScript⽀持任意浏览器，任意环境，任意系统并且是开源的。
 
优缺点:</p> <h2 id="优点"><a href="#优点" class="header-anchor">#</a> 优点：</h2> <h3 id="_1-静态类型"><a href="#_1-静态类型" class="header-anchor">#</a> 1.静态类型</h3> <p>我们都知道，JavaScript是⼀个弱类型，且是动态类型的脚本语⾔，什么变量都可以var⼀下，变   量还可以随便赋值，函数的返回值也可以是任意类型。导致代码报错是在运⾏阶段，⽽TypeScript则是静态类型，如果出错在代码编译时边会提⽰报错。
<img src="https://cdn.nlark.com/yuque/0/2020/png/292785/1608003563445-15698601-8168-4e40-abdd-649813cfbab1.png#align=left&amp;display=inline&amp;height=1160&amp;name=image.png&amp;originHeight=1160&amp;originWidth=1734&amp;size=1218046&amp;status=done&amp;style=none&amp;width=1734" alt="image.png"></p> <h3 id="_2-方便阅读"><a href="#_2-方便阅读" class="header-anchor">#</a> 2.⽅便阅读</h3> <p>类型系统实际上也是⼀个⾮常实⽤的⽂档，⼤部分的函数通过查看类型的定义就可以知道如何使
⽤，并且在VSCode（此处使⽤VSCode来代表所有代码编辑器）⾥⾯去编写TypeScript时，VSCode 会根据你当前的上下⽂，把你能⽤的类、变量、⽅法和关键字都提⽰出来，⼀⽬了然。不仅如此， TypeScript的特性还增强了VSCode的功能，包括代码补全、接⼝提⽰和点击跳转等等
如下图，我们可以很清晰的通过⿏标选中查看其属性的数据结构：
 <img src="https://cdn.nlark.com/yuque/0/2020/png/292785/1608003670578-92a4f5b0-e391-4db4-a508-5e95e2e20d0d.png#align=left&amp;display=inline&amp;height=655&amp;name=image.png&amp;originHeight=1310&amp;originWidth=1728&amp;size=3097384&amp;status=done&amp;style=none&amp;width=864" alt="image.png"></p> <h3 id="_3-减少bug"><a href="#_3-减少bug" class="header-anchor">#</a> 3. 减少bug</h3> <p>随着的项⽬的迭代，我们可能会常常遗忘该变量或者函数的返回值类型，再加之JavaScript本⾝     具有的隐式转化，让我们对类型的判断更加的困难，难以控制。后期回顾数据类型⼤⼤影响开发效率，这⾥要加⼀个类型判断，那⾥也要进⾏⼀次类型转换。
如下图中，TypeScript的类型推断，可以让我们在编码时候⽴即发现⾃⼰的类型错误。我们已经   看到了VSCode等IDE都会做出类型检查，可以将很多类型错误直接提⽰出来，这⼀点在多⼈开发，和    维护⼤型项⽬时尤为重要。项⽬复杂，函数和变量繁多时经常出现⼀个⼈改了⼀点点东西，导致项⽬崩溃的情况，在TypeScript上⾯这种情况会⼤⼤减少。
但是值得注意的是，使⽤TypeScript也只能避免⼀部分错误，不能⼀劳永逸，平时遵守严格的编    码规范，配置ESLint，代码review，以及编写单元测试等环节依然很重要！</p> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/292785/1608003688968-f3ea0cd7-11cf-4eac-b5aa-95301eb21707.png#align=left&amp;display=inline&amp;height=293&amp;name=image.png&amp;originHeight=586&amp;originWidth=1862&amp;size=782017&amp;status=done&amp;style=none&amp;width=931" alt="image.png"></p> <h3 id="_4-社区活跃"><a href="#_4-社区活跃" class="header-anchor">#</a> 4. 社区活跃</h3> <p>继Angular之后，React，Vue都相继开始⽀持TypeScript，尤其是2019年更是TypeScript爆发性     增⻓的⼀年，⼤部分第三⽅库都开始有提供给TypeScript的类型定义⽂件。</p> <h2 id="缺点"><a href="#缺点" class="header-anchor">#</a> 缺点：</h2> <h3 id="_1-学习成本"><a href="#_1-学习成本" class="header-anchor">#</a> 1. 学习成本</h3> <p><a href="https://juejin.im/post/5edd8ad8f265da76fc45362c#heading-52" target="_blank" rel="noopener noreferrer">了不起的 TypeScript ⼊⻔教程<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>
TypeScript因为是在JavaScript的基础上扩展，所以真正的学习成本并不⼤，但毕竟是静态类    型，⽽且需要理解接⼝、泛型、类、枚举类型新的概念，对于习惯了JavaScript语⾔的⼈来说很难习      惯，导致了很多同学听⻅TypeScript的第⼀反应都是拒绝，尤其是在看了⽤TypeScript编写的项⽬    后。⽽且如果你想要在现有项⽬中充分体验TypeScript，你⼜将⾯临异常⾼昂的切换成本。</p> <h3 id="_2-开发速度降低"><a href="#_2-开发速度降低" class="header-anchor">#</a> 2. 开发速度降低</h3> <p>虽然TypeScript提供了any类型，但是使⽤它的同时也失去了TypeScript的优势，建议尽量少使⽤。虽然类型系统⾃带⽂档，可以省去很多编写注释的时间，但是为所有值填上类型过程有点痛苦。
我们每⼀个数据对象都需要先定义好数据类型，从⽽在需要的是要导⼊引⽤进⾏约束变量或者函数返
回值，如下图所⽰。接⼝定义：</p> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/292785/1608003787460-bd496c1a-c372-4cdb-8d82-ac2301b67d19.png#align=left&amp;display=inline&amp;height=539&amp;name=image.png&amp;originHeight=1078&amp;originWidth=1708&amp;size=1922355&amp;status=done&amp;style=none&amp;width=854" alt="image.png"></p> <p>接⼝引⼊：
 <img src="https://cdn.nlark.com/yuque/0/2020/png/292785/1608003809285-64b05a5e-5517-45ff-a364-030cbd0b7928.png#align=left&amp;display=inline&amp;height=417&amp;name=image.png&amp;originHeight=834&amp;originWidth=1668&amp;size=1249396&amp;status=done&amp;style=none&amp;width=834" alt="image.png"></p> <h3 id="_3-部分第三方库的兼容"><a href="#_3-部分第三方库的兼容" class="header-anchor">#</a> 3. 部分第三⽅库的兼容</h3> <p>随着TypeScript的愈加⽕爆，很多依赖包都⽀持了TypeScript，但是依然有⼀部分还没有⽀持，如果你的项⽬刚好依赖了它们⽽你还想使⽤TypeScript的话，那你就需要为他添加⼀个d.ts⽂件才可以使⽤，添加的过程较为⿇烦.</p> <h3 id="_4-需要编译"><a href="#_4-需要编译" class="header-anchor">#</a> 4. 需要编译</h3> <p>JavaScript是标准，是可以直接在浏览器运⾏的，但TypeScript不能直接运⾏需要经过编译，⽣成JavaScript才可以运⾏。</p> <h2 id="我们对typescript的使用"><a href="#我们对typescript的使用" class="header-anchor">#</a> 我们对TypeScript的使⽤</h2> <h3 id="_1-类型约束"><a href="#_1-类型约束" class="header-anchor">#</a> 1.  类型约束</h3> <p>对已确定的数据结构定义接⼝，在定义或者引⽤相同数据结构时引⽤接⼝类型约束，防⽌数据类型赋值和函数返回值错误。
<img src="https://cdn.nlark.com/yuque/0/2020/png/292785/1608003850142-0c75142f-45bb-4934-9350-e4f220068947.png#align=left&amp;display=inline&amp;height=566&amp;name=image.png&amp;originHeight=1132&amp;originWidth=1644&amp;size=1380264&amp;status=done&amp;style=none&amp;width=822" alt="image.png"></p> <h3 id="_2-枚举定义"><a href="#_2-枚举定义" class="header-anchor">#</a> 2.  枚举定义</h3> <p>对⼀些固定值使⽤枚举定义，可以在让其他同学在阅读代码、后期维护时可以⻅名知意，降低阅读代码成本。enum类型是对JavaScript标准数据类型的⼀个补充。   像C#等其它语⾔⼀样，使⽤枚举类型可以为⼀组数字或字符串赋予友好的名字。
 
 <img src="https://cdn.nlark.com/yuque/0/2020/png/292785/1608003876216-63978e29-faed-4ce3-a233-cf3338e22b0e.png#align=left&amp;display=inline&amp;height=364&amp;name=image.png&amp;originHeight=728&amp;originWidth=1696&amp;size=690338&amp;status=done&amp;style=none&amp;width=848" alt="image.png"></p> <h3 id="_3-bpmn解析模式"><a href="#_3-bpmn解析模式" class="header-anchor">#</a> 3.   BPMN解析模式</h3> <p>我们在bpmn.js本⾝⾃⾝api解析对象与Vue的data层之间建⽴了⼀层数据解析层，并且会根据Vue 所需的data层数据结构对每个bpmn结构元素设计出较为合理的数据结构，以便于视图层渲染和复⽤。在此解析层所有的数据都会预先在typing.fixflow.d.ts⽂件中定义好，⽤来约束解析出来的结果是我们所必须数据结构。这样的设计可以避免⼀些数据层级过深导致某些属性解析缺失，或者在后期迭代的过程中数据结构变更，⽽未能将所有的引⽤更替。</p> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/292785/1608003923670-0f205e05-adfb-4fdd-94bc-7cf43b523f6f.png#align=left&amp;display=inline&amp;height=735&amp;name=image.png&amp;originHeight=1470&amp;originWidth=2120&amp;size=2645828&amp;status=done&amp;style=none&amp;width=1060" alt="image.png"></p> <h3 id="_4-class-style"><a href="#_4-class-style" class="header-anchor">#</a> 4.   class-style</h3> <p>由于vue对typescript⽀持的装饰器(库)，本项⽬引⽤vue-property-decorator(依赖vue-class- component)进⾏组件编写。通过该插件可以使⽤类的写法替换原本组件的对象写法，让组件的编写    更为优雅。
<img src="https://cdn.nlark.com/yuque/0/2020/png/292785/1608003972539-d387ec9e-f282-49b3-bf73-238cfd131c17.png#align=left&amp;display=inline&amp;height=778&amp;name=image.png&amp;originHeight=1556&amp;originWidth=2082&amp;size=2533701&amp;status=done&amp;style=none&amp;width=1041" alt="image.png"></p> <h3 id="_5-props类型约定"><a href="#_5-props类型约定" class="header-anchor">#</a> 5.   Props类型约定</h3> <p>在封装组件时候会对传⼊的值进⾏类型约定，可以尽量避免因传⼊的值数据结构与组件内部处理不
⼀致，导致组件内渲染出错。
 <img src="https://cdn.nlark.com/yuque/0/2020/png/292785/1608004038846-0941f56c-7dd4-4f42-9d52-48519d46c31c.png#align=left&amp;display=inline&amp;height=626&amp;name=image.png&amp;originHeight=1252&amp;originWidth=2308&amp;size=2384614&amp;status=done&amp;style=none&amp;width=1154" alt="image.png"></p> <h3 id="_6-不足"><a href="#_6-不足" class="header-anchor">#</a> 6.    不⾜</h3> <p>a.       许多地⽅没有使⽤TS的新特性</p> <p>b.       依旧有许多地⽅使⽤any类型</p> <h3 id="其他"><a href="#其他" class="header-anchor">#</a> 其他</h3> <h4 id="函数重载"><a href="#函数重载" class="header-anchor">#</a> 函数重载</h4> <h5 id="_2个或2个以上的同名普通函数-但参数不一样-这时会出现函数重载的情况。ts中重载-通过为一个函数提供多个函数类型定义走多种功能目的"><a href="#_2个或2个以上的同名普通函数-但参数不一样-这时会出现函数重载的情况。ts中重载-通过为一个函数提供多个函数类型定义走多种功能目的" class="header-anchor">#</a> 2个或2个以上的同名普通函数，但参数不⼀样，这时会出现函数重载的情况。TS中重载,通过为⼀个函数提供多个函数类型定义⾛多种功能⽬的</h5> <div class="language-basic extra-class"><pre class="language-basic"><code><span class="token operator">/</span><span class="token operator">/</span> 普通js 
<span class="token keyword">function</span> css<span class="token punctuation">(</span>config<span class="token punctuation">)</span>{}
<span class="token keyword">function</span> css<span class="token punctuation">(</span>config<span class="token punctuation">,</span> value<span class="token punctuation">)</span>{} <span class="token operator">/</span><span class="token operator">/</span> 会替换上⾯的⽅法 
<span class="token operator">/</span><span class="token operator">/</span> TS 中 
<span class="token keyword">function</span> getInfo<span class="token punctuation">(</span><span class="token keyword">name</span><span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">string</span>{} 
<span class="token keyword">function</span> getInfo<span class="token punctuation">(</span>age<span class="token punctuation">:</span> number<span class="token punctuation">)</span><span class="token punctuation">:</span> number{} 
<span class="token keyword">function</span> getInfo<span class="token punctuation">(</span><span class="token function">str</span><span class="token punctuation">:</span> any<span class="token punctuation">)</span><span class="token punctuation">:</span> any{} <span class="token operator">/</span><span class="token operator">/</span> 根据参数不同，⾛不同逻辑
</code></pre></div><h4 id="类里面的三种修饰符"><a href="#类里面的三种修饰符" class="header-anchor">#</a> 类⾥⾯的三种修饰符</h4> <div class="language-basic extra-class"><pre class="language-basic"><code>public 共有 类内部、⼦类、类外部都可以访问 
protected 保护 类⾥、⼦类可以访问，类外部不可以访问 
private 私有 类⾥可以访问，⼦类和类外不可访问
</code></pre></div><h4 id="ts抽象类-提供给其他类继承的基础类-必须实现抽象类继承-否则报错"><a href="#ts抽象类-提供给其他类继承的基础类-必须实现抽象类继承-否则报错" class="header-anchor">#</a> TS抽象类：提供给其他类继承的基础类，必须实现抽象类继承，否则报错</h4> <div class="language-basic extra-class"><pre class="language-basic"><code>abstract class Animal { <span class="token operator">/</span><span class="token operator">/</span> 基类 
	public <span class="token keyword">name</span><span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">;</span> 
  constructor<span class="token punctuation">(</span><span class="token keyword">name</span><span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">)</span> { 
  	this.<span class="token keyword">name</span> <span class="token operator">=</span> <span class="token keyword">name</span><span class="token punctuation">;</span> 
  }
  abstract eat<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>any<span class="token punctuation">;</span> <span class="token operator">/</span><span class="token operator">/</span> 定义⽅法 
} 
class Cat extends Animal {
  constructor<span class="token punctuation">(</span><span class="token keyword">name</span><span class="token punctuation">:</span> any<span class="token punctuation">)</span> {
  	super<span class="token punctuation">(</span><span class="token keyword">name</span><span class="token punctuation">)</span> 
  }
  eat<span class="token punctuation">(</span><span class="token punctuation">)</span> {
  	xxxx 
  } 
} 
var c <span class="token operator">=</span> new Cat<span class="token punctuation">(</span>'<span class="token keyword">name</span>'<span class="token punctuation">)</span>
c.eat<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span><span class="token operator">/</span> 必须调⽤定义⽅法，否则报错
</code></pre></div><h4 id="接口的概念-对json约束"><a href="#接口的概念-对json约束" class="header-anchor">#</a> 接⼝的概念：对JSON约束</h4> <div class="language-basic extra-class"><pre class="language-basic"><code>interface FullName { 
  firstName<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">;</span> 
  lastName<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">;</span>
}
<span class="token keyword">function</span> printName<span class="token punctuation">(</span><span class="token keyword">name</span><span class="token punctuation">:</span> FullName<span class="token punctuation">)</span> { <span class="token operator">/</span><span class="token operator">/</span> FullName 对应上⾯定义 
	console.<span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">name</span>. firstName <span class="token operator">+</span> <span class="token keyword">name</span>. lastName<span class="token punctuation">)</span> 
}
</code></pre></div><h4 id="加密函数类型接口"><a href="#加密函数类型接口" class="header-anchor">#</a> 加密函数类型接⼝</h4> <div class="language-basic extra-class"><pre class="language-basic"><code>interface encrypt {
	<span class="token punctuation">(</span><span class="token keyword">key</span><span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">,</span> value<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">string</span> <span class="token operator">/</span><span class="token operator">/</span> 约束函数：传值和返回值，可做批量约束
}
var md5<span class="token punctuation">:</span> encrypt <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token keyword">key</span><span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">,</span> value<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">string</span> { 
	<span class="token keyword">return</span> <span class="token keyword">key</span> <span class="token operator">+</span> value<span class="token punctuation">;</span> 
} 
md5<span class="token punctuation">(</span>'<span class="token keyword">name</span>'<span class="token punctuation">,</span> 'zhangsan'<span class="token punctuation">)</span>
</code></pre></div><h4 id="类-类型接口-常用-类似于抽象类"><a href="#类-类型接口-常用-类似于抽象类" class="header-anchor">#</a> '类'类型接⼝，常⽤，类似于抽象类</h4> <div class="language-basic extra-class"><pre class="language-basic"><code>interface Animal { <span class="token operator">/</span><span class="token operator">/</span> 实现这个接⼝，必须有<span class="token keyword">name</span>和eat这个标准 
  <span class="token keyword">name</span><span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">;</span> 
  eat<span class="token punctuation">(</span><span class="token function">str</span><span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">)</span><span class="token punctuation">:</span>void<span class="token punctuation">;</span> 
} 
class Dog implements Animal { 
	<span class="token keyword">name</span><span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">;</span> <span class="token operator">/</span><span class="token operator">/</span> 必须存在 
  constructor<span class="token punctuation">(</span><span class="token keyword">name</span><span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">)</span> { 
  this.<span class="token keyword">name</span> <span class="token operator">=</span> <span class="token keyword">name</span> 
  } 
  eat<span class="token punctuation">(</span><span class="token punctuation">)</span> { <span class="token operator">/</span><span class="token operator">/</span> 必须存在 
  		<span class="token number">11</span> xxxx <span class="token number">12</span>
  } 
} 
var d <span class="token operator">=</span> new Dog<span class="token punctuation">(</span>'wang'<span class="token punctuation">)</span> 
d.eat<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><h4 id="接口的继承"><a href="#接口的继承" class="header-anchor">#</a> 接⼝的继承</h4> <div class="language-basic extra-class"><pre class="language-basic"><code>interface Animal { 
	eat<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>void 
} 
interface Person extends Animal { 
	work<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>void 
} 
 <span class="token operator">/</span><span class="token operator">/</span> 接⼝继承接⼝
 class Web implements Person {
   public <span class="token keyword">name</span><span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">;</span>
   constructor<span class="token punctuation">(</span><span class="token keyword">name</span><span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">)</span> { 
   		this.<span class="token keyword">name</span> <span class="token operator">=</span> <span class="token keyword">name</span> 
   } 
   eat<span class="token punctuation">(</span><span class="token punctuation">)</span>{ xxx }
   work<span class="token punctuation">(</span><span class="token punctuation">)</span> { xxx } 
 } 
 class Programer { 
   constructor<span class="token punctuation">(</span><span class="token keyword">name</span><span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">)</span> { 
   		super<span class="token punctuation">(</span><span class="token keyword">name</span><span class="token punctuation">)</span> 
   } 
   coding<span class="token punctuation">(</span><span class="token punctuation">)</span> { xxx } 
 } 
<span class="token operator">/</span><span class="token operator">/</span> extends继承普通构造函数可以直接调⽤私有函数coding 
<span class="token operator">/</span><span class="token operator">/</span> implements配合interface接⼝，定义eat和wrok⽅法
class Web extends Programer implements Person { 
	constructor<span class="token punctuation">(</span><span class="token keyword">name</span><span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">)</span> { 
  	super<span class="token punctuation">(</span><span class="token keyword">name</span><span class="token punctuation">)</span> 
  } 
  eat<span class="token punctuation">(</span><span class="token punctuation">)</span>{ xxx } 
  work<span class="token punctuation">(</span><span class="token punctuation">)</span> { xxx } 
}
</code></pre></div><h4 id="interface-与-type-区别"><a href="#interface-与-type-区别" class="header-anchor">#</a> interface 与 type 区别</h4> <p><a href="https://juejin.im/post/5c2723635188252d1d34dc7d#heading-11" target="_blank" rel="noopener noreferrer">Typescript 中的 interface 和 type 到底有什么区别<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>
相同点：
a.       都可以描述⼀个对象或者函数
b.       都允许拓展（extends）
c.        都可以被类实现（implements）
 不同点：</p> <p>a.       type 可以声明基本类型别名，联合类型，元组等类型
b.       interface 能够声明合并</p> <h4 id="泛型-可以支持不特定的数据类型-要求-传入的参数和返回的参数必须一致"><a href="#泛型-可以支持不特定的数据类型-要求-传入的参数和返回的参数必须一致" class="header-anchor">#</a> 泛型：可以⽀持不特定的数据类型，要求：传⼊的参数和返回的参数必须⼀致</h4> <div class="language-basic extra-class"><pre class="language-basic"><code> <span class="token keyword">function</span> getData<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">(</span>value<span class="token punctuation">:</span> T<span class="token punctuation">)</span><span class="token punctuation">:</span>T { 
 		<span class="token keyword">return</span> value <span class="token operator">/</span><span class="token operator">/</span> 返回值也必须是定义类型T 
 } 
 getData<span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>'<span class="token number">12345</span>'<span class="token punctuation">)</span> <span class="token operator">/</span><span class="token operator">/</span> T是<span class="token keyword">string</span>，所以传参也必须是字符串 
 getData<span class="token operator">&lt;</span>number<span class="token operator">&gt;</span><span class="token punctuation">(</span>'<span class="token number">12345</span>'<span class="token punctuation">)</span> <span class="token operator">/</span><span class="token operator">/</span> T是number，所以传参不是字符串，报错
</code></pre></div><p></p> <h4 id="泛型类-最小堆算法"><a href="#泛型类-最小堆算法" class="header-anchor">#</a> 泛型类：最⼩堆算法</h4> <div class="language-basic extra-class"><pre class="language-basic"><code>class MinClass<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> { 
  public list<span class="token punctuation">:</span>T[] <span class="token operator">=</span> []<span class="token punctuation">;</span> 
  add<span class="token punctuation">(</span>value<span class="token punctuation">:</span> T<span class="token punctuation">)</span><span class="token punctuation">:</span>void { 
  	this.list.push<span class="token punctuation">(</span>value<span class="token punctuation">)</span> 
  } 
  <span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>T { 
    var minNum <span class="token operator">=</span> this.list[<span class="token number">0</span>] 
    <span class="token keyword">return</span> minNum 
  } 
} 
var m1 <span class="token operator">=</span> new MinClass<span class="token operator">&lt;</span>number<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span><span class="token operator">/</span> 定义T为number类型 
m1.add<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token operator">/</span> 传参也为数字类型 
mi.<span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token operator">/</span> 返回值也为数字类型
</code></pre></div><h4 id="泛型接口"><a href="#泛型接口" class="header-anchor">#</a> 泛型接⼝</h4> <div class="language-basic extra-class"><pre class="language-basic"><code><span class="token operator">/</span><span class="token operator">/</span> 第⼀种写法： 
interface config { 
	<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">(</span>value<span class="token punctuation">:</span>T<span class="token punctuation">)</span><span class="token punctuation">:</span>T<span class="token punctuation">;</span> 
} 
var getData<span class="token punctuation">:</span>config <span class="token operator">=</span> <span class="token keyword">function</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">(</span>value<span class="token punctuation">:</span>T<span class="token punctuation">)</span><span class="token punctuation">:</span>T { 
	<span class="token keyword">return</span> value 
} 
getData<span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>'张三'<span class="token punctuation">)</span> <span class="token operator">/</span><span class="token operator">/</span> 通过 
getData<span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span> <span class="token operator">/</span><span class="token operator">/</span>报错 
<span class="token operator">/</span><span class="token operator">/</span> 第⼆种写法： 
interface config<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> { 
	<span class="token punctuation">(</span>value<span class="token punctuation">:</span>T<span class="token punctuation">)</span><span class="token punctuation">:</span>T<span class="token punctuation">;</span> 
} 
<span class="token keyword">function</span> getData<span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">(</span>value<span class="token punctuation">:</span>T<span class="token punctuation">)</span><span class="token punctuation">:</span>T { 
	<span class="token keyword">return</span> value
} 
var myData<span class="token punctuation">:</span>config<span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token operator">&gt;</span> <span class="token operator">=</span> getData 
myData<span class="token punctuation">(</span>'abc'<span class="token punctuation">)</span> <span class="token operator">/</span><span class="token operator">/</span> 通过 
myData<span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span> <span class="token operator">/</span><span class="token operator">/</span> 报错
</code></pre></div><p></p> <h4 id="类型编程"><a href="#类型编程" class="header-anchor">#</a> 类型编程</h4> <h5 id="typescript-进阶⸺类型编程-通过typescript操作符-把类型当作参数进行逻辑处理-从而获得新的类型的过程称为类型编程。其中大部分都是通过泛型来引入-因此泛型是ts类型编程的基础。"><a href="#typescript-进阶⸺类型编程-通过typescript操作符-把类型当作参数进行逻辑处理-从而获得新的类型的过程称为类型编程。其中大部分都是通过泛型来引入-因此泛型是ts类型编程的基础。" class="header-anchor">#</a> （   <a href="https://bytedance.feishu.cn/docs/doccnFqnqcIlHHa6TGqukjD9zAh" target="_blank" rel="noopener noreferrer">TypeScript  进阶⸺类型编程<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>）：通过TypeScript操作符，把类型当作参数进⾏逻辑处理，从⽽获得新的类型的过程称为类型编程。其中⼤部分都是通过泛型来引⼊，因此泛型是TS类型编程的基础。</h5> <h4 id="声明类型参数有三种-泛型-、in映射、infer待推断"><a href="#声明类型参数有三种-泛型-、in映射、infer待推断" class="header-anchor">#</a> 声明类型参数有三种：泛型&lt;&gt;、in映射、infer待推断</h4> <h4 id="同态转换-同态转换会复制原有的所有属性的所有修饰词-在此基础上允许额外的增加新的属性修饰词。两个代数结构保持了结构不变的映射-则称这两个代数结构是同态的。ts中类型索引和类型映射-是同态的。"><a href="#同态转换-同态转换会复制原有的所有属性的所有修饰词-在此基础上允许额外的增加新的属性修饰词。两个代数结构保持了结构不变的映射-则称这两个代数结构是同态的。ts中类型索引和类型映射-是同态的。" class="header-anchor">#</a> 同态转换：同态转换会复制原有的所有属性的所有修饰词，在此基础上允许额外的增加新的属性修饰词。两个代数结构保持了结构不变的映射，则称这两个代数结构是同态的。TS中类型索引和类型映射         是同态的。</h4> <div class="language-basic extra-class"><pre class="language-basic"><code> <span class="token keyword">type</span> <span class="token keyword">Common</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">=</span> { [K <span class="token function">in</span> keyof T]<span class="token punctuation">:</span> T[K] }
</code></pre></div><p>条件分布式
当满⾜条件，
a.       存在联合类型作为输⼊
b.       有条件运算extends
c.        联合类型所指的⼊参必须是裸类型（没有被其他类型包裹）</p> <div class="language-basic extra-class"><pre class="language-basic"><code><span class="token punctuation">(</span>A | B | C<span class="token punctuation">)</span> extends U ? X <span class="token punctuation">:</span> Y <span class="token operator">=</span> <span class="token punctuation">(</span>A extends U ? X <span class="token punctuation">:</span> Y<span class="token punctuation">)</span> | <span class="token punctuation">(</span>B extends U ? X <span class="token punctuation">:</span> Y<span class="token punctuation">)</span> | <span class="token punctuation">(</span>C extends U ? X <span class="token punctuation">:</span> Y<span class="token punctuation">)</span>  
<span class="token punctuation">(</span>A <span class="token operator">&amp;</span> B <span class="token operator">&amp;</span> C<span class="token punctuation">)</span> extends U ? X <span class="token punctuation">:</span> Y <span class="token operator">=</span> <span class="token punctuation">(</span>A extends U ? X <span class="token punctuation">:</span> Y<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>B extends U ? X <span class="token punctuation">:</span> Y<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>C extends U ? X <span class="token punctuation">:</span> Y<span class="token punctuation">)</span>
</code></pre></div><p>官⽅类型递归例⼦：</p> <div class="language-basic extra-class"><pre class="language-basic"><code> <span class="token keyword">type</span> LinkedList<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">=</span> T <span class="token operator">&amp;</span> { <span class="token keyword">next</span><span class="token punctuation">:</span> LinkedList<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> }<span class="token punctuation">;</span> 
class Person { 
	<span class="token keyword">name</span><span class="token punctuation">:</span> <span class="token keyword">string</span> 
} 
<span class="token function">let</span> people<span class="token punctuation">:</span> LinkedList<span class="token operator">&lt;</span>Person<span class="token operator">&gt;</span><span class="token punctuation">;</span> 
<span class="token function">let</span> s <span class="token operator">=</span> people.<span class="token keyword">name</span><span class="token punctuation">;</span> 
<span class="token function">let</span> s <span class="token operator">=</span> people.<span class="token keyword">next</span>.<span class="token keyword">name</span><span class="token punctuation">;</span> 
<span class="token function">let</span> s <span class="token operator">=</span> people.<span class="token keyword">next</span>.<span class="token keyword">next</span>.<span class="token keyword">name</span><span class="token punctuation">;</span>
</code></pre></div><h1 id="综合考虑"><a href="#综合考虑" class="header-anchor">#</a> 综合考虑</h1> <p>在开始专业流程平台项⽬之前我们主要是基于以下⼏点考虑
1.       新项⽬。从头开发，没有重构⽼代码的成本。</p> <p>2.       对新技术的尝试。组内⼈员对新技术的热忱度都很⾼，希望通过⼀个项⽬来实践TypeScript。
3.       多⼈协作。专业流程平台项⽬庞⼤，且BPMN⽂件解析的数据需要来回传递和修改。
4.       不同功能模块之间数据获取和传递。对于类型系统的需求⼤，每个⼈来编写时都可以避免类型错误，并且⽅便获取参数类型进⾏操作。
5.       代码规范化。所以代码越规范越好，TypeScript便于理解，并配有详细的注释。
6.       接⼝返回值固定类型。可以更好的进⾏类型推断。
7.       项⽬持续迭代和维护。使⽤TypeScript可以⽅便⼤家阅读和后续扩展、重构。</p> <h1 id="结论"><a href="#结论" class="header-anchor">#</a> 结论</h1> <p>个⼈认为专业流程平台项⽬接⼊TypeScript是⼀个⾮常好的技术⽅案，⽽且从 Vue2.5 之后，Vue 对 TypeScript有更好的⽀持。在本项⽬的实践开发过程中，我觉得以下⼏点是需要注意并遵守的：
a.       对定义的变量、参数以及函数的返回值进⾏接⼝类型约束
b.       对与⼀些需要固定的值，可以使⽤枚举给其⻅名知意的变量名
c.        在使⽤class⻛格封装组件时候，我们在props传值时需要对传⼊组件内部值进⾏类型约定
d.       能不⽤any类型定义变量类型时，我们则不⽤
e.       我们尽量使⽤TS带了的新特性，让代码更为的优雅，例如：可选链 ?. 、双问号操作符 ?? 等
 
是否使⽤TypeScript，我们认为在做出选择之前，你需要认真的衡量⼀下投⼊产出⽐， TypeScript带来的优势是否对当前的项⽬有很⼤提升，是否值得花费⼤量的时间去对现有项⽬进⾏重     构，值得注意的⼀点是，不管TypeScript最终会不会被应⽤到项⽬中，你都应该学会掌握它。
最后，对于取舍问题，我们感觉是：如果你的项⽬是⼤型项⽬，第三⽅库，或者其他需要持续维护的项⽬，上TypeScript吧；如果你的项⽬是活动，分享⻚⾯，等短周期并且不需要持续维护的项
⽬，想⽤哪个⽤哪个。</p> <h1 id="视频回顾"><a href="#视频回顾" class="header-anchor">#</a> 视频回顾</h1> <p><a href="https://www.feishu.cn/space/file/boxcnNIDZfaPYLA1u1IML2NVC7U" target="_blank" rel="noopener noreferrer">专业流程平台Vue+TypeScript实践分享.mp4<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> <a href="https://www.yuque.com/attachments/yuque/0/2020/pdf/292785/1608013141405-43111e8e-88ff-4ba7-b1bc-b53437308737.pdf" target="_blank" rel="noopener noreferrer">专业流程平台Vue+TypeScript实践分享.pdf<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h4 id="ts小技巧"><a href="#ts小技巧" class="header-anchor">#</a> ts小技巧</h4> <p><a href="https://cy188.github.io/2021/04/09/2-TypeScript%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3-4.2/" target="_blank" rel="noopener noreferrer">中文文档<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><strong>Partial</strong>
将传入的属性变为可选项</p> <div class="language- extra-class"><pre class="language-text"><code>interface IPeople {
    title: string;
    name: string;
}

const people: Partial&lt;IPeople&gt; = {
    title: 'Delete inactive users'
};
</code></pre></div><p><strong>Record&lt;K, T&gt;</strong>
类型参数K提供了对象属性名联合类型，类型参数T提供了对象属性的类型</p> <div class="language- extra-class"><pre class="language-text"><code>interface Person {
  name: string;
}

// 将x, y 作为Person的key
type Peoples = Record&lt;&quot;x&quot; | &quot;y&quot;, Person&gt;;

const P: Peoples = {
    x: {
        name: '张三'
    },
    y: {
        name: '李四'
    }
}
</code></pre></div><p>**Readonly **
把传入的类型变为只读状态</p> <div class="language- extra-class"><pre class="language-text"><code>interface Person {
  name: string;
  age: number;
}

const p: Readonly&lt;Person&gt; = {
    name: '张三',
    age: 22
}

p.name = '李四'; // 无法分配到 &quot;name&quot; ，因为它是只读属性
</code></pre></div><p><strong>Required</strong>
把传入的类型变为必填状态</p> <div class="language- extra-class"><pre class="language-text"><code>interface Person {
    name?: string;
    age?: number;
}

const p: Required&lt;Person&gt; = {
    name: '张三',
    age: 22
}
</code></pre></div><p><strong>Pick&lt;T, S&gt;</strong>
在 T 中，过滤掉非 S 的类型</p> <div class="language- extra-class"><pre class="language-text"><code>interface IPerson {
    name: string;
    age: number;
}

type TP = Pick&lt;IPerson, 'name'&gt;;

const p: TP = {
    age: 22, // 对象文字可以只指定已知属性，并且“age”不在类型“TP”中
    name: '张三'
}
</code></pre></div><p><strong>Omit&lt;T, K&gt;</strong>
在 T 中删除对应的 K</p> <div class="language- extra-class"><pre class="language-text"><code>interface IPerson {
    name: string;
    age: number;
}

type TP = Omit&lt;IPerson, 'age'&gt;;

const p: TP = {
    name: '张三'
}
</code></pre></div><p><strong>Exclude&lt;T, U&gt;</strong>
该工具类型能够从类型T中剔除所有可以赋值给类型U的类型</p> <div class="language- extra-class"><pre class="language-text"><code>type T0 = Exclude&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot;&gt;;
// 相当于 type T0 = &quot;b&quot; | &quot;c&quot;

type T1 = Exclude&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot; | &quot;b&quot;&gt;;
// 相当于 type T1 = &quot;c&quot;

type T2 = Exclude&lt;string | number | (() =&gt; void), Function&gt;;
// 相当于 type T2 = string | number
</code></pre></div><p><strong>Extract&lt;T, U&gt;</strong>
“Extract&lt;T, U&gt;”工具类型与“Exclude&lt;T, U&gt;”工具类型是互补的，它能够从类型T中获取所有可以赋值给类型U的类型</p> <div class="language- extra-class"><pre class="language-text"><code>type T0 = Extract&lt;'a' | 'b' | 'c', 'a' | 'f'&gt;;
// 相当于 type T0 = 'a';

type T1 = Extract&lt;string | (() =&gt; void), Function&gt;;
// 相当于 type T1 = () =&gt; void;

type T2 = Extract&lt;string | number, boolean&gt;;
// 因为没有交集，相当于 type T2 = never;
</code></pre></div><p><strong>ReturnType</strong>
该工具类型能够获取函数类型T的返回值类型</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// string</span>
type <span class="token constant">T0</span> <span class="token operator">=</span> ReturnType<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> string<span class="token operator">&gt;</span><span class="token punctuation">;</span>

<span class="token comment">// { a: string; b: number }</span>
type <span class="token constant">T1</span> <span class="token operator">=</span> ReturnType<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token literal-property property">a</span><span class="token operator">:</span> string<span class="token punctuation">;</span> b<span class="token operator">:</span> number<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre></div></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/SetoInlandSea/blog/edit/docs/docs/interview/js/ts.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.1b73a34e.js" defer></script><script src="/blog/assets/js/2.733019b2.js" defer></script><script src="/blog/assets/js/27.704b5b19.js" defer></script>
  </body>
</html>
